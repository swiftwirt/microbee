{"entries":[{"timestamp":1764550659623,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":367,"diffs":[[1,""]]},{"start1":1,"length1":254,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":210,"length1":239,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":237,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"ble.ts","value":"namespace Robot.Bluetooth {\n    const TX_POWER_MAX = 7;\n    const NEWLINE = serial.delimiters(Delimiters.NewLine);\n\n    bluetooth.startUartService();\n    bluetooth.setTransmitPower(TX_POWER_MAX);\n\n    bluetooth.onBluetoothConnected(() => {\n        Robot.State.setConnected(true);\n        Robot.Display.showIconIfChanged(IconNames.Heart);\n    });\n\n    bluetooth.onBluetoothDisconnected(() => {\n        Robot.State.setConnected(false);\n        // Cool disconnect animation\n        basic.showIcon(IconNames.Sad);\n        soundExpression.sad.play();\n        basic.pause(300);\n        basic.showIcon(IconNames.Asleep);\n        basic.pause(300);\n        basic.showIcon(IconNames.Confused);\n        basic.pause(300);\n        Robot.Display.showIconIfChanged(IconNames.Skull);\n    });\n\n    bluetooth.onUartDataReceived(NEWLINE, () => {\n        let cmd = bluetooth.uartReadUntil(NEWLINE).trim();\n        Robot.Dispatcher.dispatch(cmd);\n    });\n}"},{"type":"added","filename":"bme680.ts","value":"namespace Robot.Drivers.BME680 {\n    // ──────────────── BME680 CONSTANTS ────────────────\n    const BME680_REG_CHIP_ID = 0xD0;\n    const BME680_CHIP_ID = 0x61;\n\n    const BME680_REG_CTRL_HUM = 0x72;\n    const BME680_REG_CTRL_MEAS = 0x74;\n    const BME680_REG_CONFIG = 0x75;\n\n    const BME680_REG_PRESS_MSB = 0x1F;\n    const BME680_REG_GAS_MSB = 0x2A;\n\n    let bme680Detected = false;\n    let bme680Initialized = false;\n\n    // ───── BME680 CALIBRATION COEFFICIENTS (par_*) ─────\n    let par_t1 = 0; let par_t2 = 0; let par_t3 = 0;\n    let par_p1 = 0; let par_p2 = 0; let par_p3 = 0;\n    let par_p4 = 0; let par_p5 = 0; let par_p6 = 0;\n    let par_p7 = 0; let par_p8 = 0; let par_p9 = 0; let par_p10 = 0;\n    let par_h1 = 0; let par_h2 = 0; let par_h3 = 0;\n    let par_h4 = 0; let par_h5 = 0; let par_h6 = 0; let par_h7 = 0;\n\n    let tFine = 0; // Global fine temperature\n\n    function toSigned16(x: number): number { return x > 32767 ? x - 65536 : x; }\n    function toSigned8(x: number): number { return x > 127 ? x - 256 : x; }\n\n    function readBME680Calibration(): void {\n        let w = pins.createBuffer(1);\n        let b: Buffer;\n        const addr = Robot.Config.BME680_I2C_ADDRESS;\n\n        // ---- temperature calibration ----\n        w[0] = 0x8A; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_t2 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0x8C; pins.i2cWriteBuffer(addr, w, false);\n        par_t3 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n\n        w[0] = 0xE9; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_t1 = b[0] | (b[1] << 8);\n\n        // ---- pressure calibration ----\n        w[0] = 0x8E; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p1 = b[0] | (b[1] << 8);\n\n        w[0] = 0x90; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p2 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0x92; pins.i2cWriteBuffer(addr, w, false);\n        par_p3 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n\n        w[0] = 0x94; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p4 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0x96; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p5 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0x99; pins.i2cWriteBuffer(addr, w, false);\n        par_p6 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n\n        w[0] = 0x98; pins.i2cWriteBuffer(addr, w, false);\n        par_p7 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n\n        w[0] = 0x9C; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p8 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0x9E; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 2, false);\n        par_p9 = toSigned16(b[0] | (b[1] << 8));\n\n        w[0] = 0xA0; pins.i2cWriteBuffer(addr, w, false);\n        par_p10 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n\n        // ---- humidity calibration ----\n        w[0] = 0xE1; pins.i2cWriteBuffer(addr, w, false);\n        b = pins.i2cReadBuffer(addr, 7, false);\n        let e1 = b[0]; let e2 = b[1]; let e3 = b[2];\n        let e4 = b[3]; let e5 = b[4]; let e6 = b[5]; let e7 = b[6];\n\n        par_h1 = (e3 << 4) | (e2 & 0x0F);\n        par_h2 = toSigned16((e1 << 4) | (e2 >> 4));\n        par_h3 = toSigned8(e4);\n        par_h4 = toSigned8(e5);\n        par_h5 = toSigned8(e6);\n        par_h6 = toSigned8(e7);\n\n        w[0] = 0xE8; pins.i2cWriteBuffer(addr, w, false);\n        par_h7 = toSigned8(pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false));\n    }\n\n    export function init(): boolean {\n        if (bme680Initialized) return bme680Detected;\n        const addr = Robot.Config.BME680_I2C_ADDRESS;\n\n        try {\n            let w = pins.createBuffer(1);\n            w[0] = BME680_REG_CHIP_ID;\n            pins.i2cWriteBuffer(addr, w, false);\n            let chipId = pins.i2cReadNumber(addr, NumberFormat.UInt8LE, false);\n\n            if (chipId != BME680_CHIP_ID) {\n                bme680Detected = false;\n                bme680Initialized = true;\n                return false;\n            }\n\n            readBME680Calibration();\n\n            // Config: Humidity x1, Temp/Press x1, Forced Mode, IIR Off\n            let cfg = pins.createBuffer(2);\n            cfg[0] = BME680_REG_CTRL_HUM; cfg[1] = 0x01;\n            pins.i2cWriteBuffer(addr, cfg, false);\n\n            cfg[0] = BME680_REG_CTRL_MEAS; cfg[1] = 0x25;\n            pins.i2cWriteBuffer(addr, cfg, false);\n\n            cfg[0] = BME680_REG_CONFIG; cfg[1] = 0x00;\n            pins.i2cWriteBuffer(addr, cfg, false);\n\n            bme680Detected = true;\n        } catch (e) {\n            bme680Detected = false;\n        }\n        bme680Initialized = true;\n        return bme680Detected;\n    }\n\n    function readRawAll(): { t: number, p: number, h: number } {\n        const addr = Robot.Config.BME680_I2C_ADDRESS;\n\n        // Trigger forced measurement\n        let w = pins.createBuffer(2);\n        w[0] = BME680_REG_CTRL_MEAS; w[1] = 0x25;\n        pins.i2cWriteBuffer(addr, w, false);\n        basic.pause(30); // Wait for conversion\n\n        let start = pins.createBuffer(1);\n        start[0] = BME680_REG_PRESS_MSB;\n        pins.i2cWriteBuffer(addr, start, false);\n        let buf = pins.i2cReadBuffer(addr, 8, false);\n\n        let adcPress = (buf[0] << 12) | (buf[1] << 4) | (buf[2] >> 4);\n        let adcTemp = (buf[3] << 12) | (buf[4] << 4) | (buf[5] >> 4);\n        let adcHum = (buf[6] << 8) | buf[7];\n\n        return { t: adcTemp, p: adcPress, h: adcHum };\n    }\n\n    function compensateTemperature(adcTemp: number): number {\n        let var1 = (adcTemp / 16384.0 - par_t1 / 1024.0) * par_t2;\n        let var2 = (((adcTemp / 131072.0) - (par_t1 / 8192.0)) *\n            ((adcTemp / 131072.0) - (par_t1 / 8192.0))) * (par_t3 * 16.0);\n        tFine = var1 + var2;\n        return tFine / 5120.0;\n    }\n\n    function compensatePressure(adcPress: number): number {\n        let var1 = tFine / 2.0 - 64000.0;\n        let var2 = var1 * var1 * par_p6 / 131072.0;\n        var2 = var2 + var1 * par_p5 * 2.0;\n        var2 = var2 / 4.0 + par_p4 * 65536.0;\n\n        var1 = (par_p3 * var1 * var1 / 16384.0 + par_p2 * var1) / 524288.0;\n        var1 = (1.0 + var1 / 32768.0) * par_p1;\n\n        if (var1 == 0) return -1;\n\n        let press = 1048576.0 - adcPress;\n        press = (press - var2 / 4096.0) * 6250.0 / var1;\n\n        let var3 = (press / 256.0) * (press / 256.0) * (press / 256.0) * (par_p10 / 131072.0);\n        var1 = par_p9 * press * press / 2147483648.0;\n        var2 = press * par_p8 / 32768.0;\n\n        return press + (var1 + var2 + var3 + par_p7 * 128.0) / 16.0;\n    }\n\n    function compensateHumidity(adcHum: number, tempComp: number): number {\n        let var1 = adcHum - (par_h1 * 16.0 + (par_h3 / 2.0) * tempComp);\n        let var2 = var1 * (par_h2 / 262144.0 * (1.0 + (par_h4 / 16384.0) * tempComp +\n            (par_h5 / 1048576.0) * tempComp * tempComp));\n        let var3 = par_h6 / 16384.0;\n        let var4 = par_h7 / 2097152.0;\n        let hum = var2 + (var3 + var4 * tempComp) * var2 * var2;\n        return Math.max(0, Math.min(100, hum));\n    }\n\n    export function readSample(): { ambient: number, humidity: number, pressure: number, gas: number } {\n        if (!bme680Detected) return { ambient: -999, humidity: -1, pressure: -1, gas: -1 };\n\n        try {\n            let raw = readRawAll();\n            let tempC = compensateTemperature(raw.t);\n            let pPa = compensatePressure(raw.p);\n            let pHpa = pPa / 100.0;\n            let h = compensateHumidity(raw.h, tempC);\n\n            // Gas reading (optional/unreliable on some modules without heating setup)\n            let gas = -1;\n            try {\n                let w = pins.createBuffer(1);\n                w[0] = BME680_REG_GAS_MSB;\n                pins.i2cWriteBuffer(Robot.Config.BME680_I2C_ADDRESS, w, false);\n                let gb = pins.i2cReadBuffer(Robot.Config.BME680_I2C_ADDRESS, 2, false);\n                gas = (gb[0] << 8) | gb[1];\n            } catch (e) { gas = -1; }\n\n            return {\n                ambient: Math.round(tempC * 1),\n                humidity: Math.round(h * 1),\n                pressure: Math.round(pHpa * 1),\n                gas: gas\n            };\n        } catch (e) {\n            return { ambient: -999, humidity: -1, pressure: -1, gas: -1 };\n        }\n    }\n}"},{"type":"added","filename":"config.ts","value":"namespace Robot.Config {\n    // ─── PIN DEFINITIONS ─────────────────────────────────────────────────────────\n    export const PIN_MOTOR_LEFT_FWD = AnalogPin.P12;\n    export const PIN_MOTOR_LEFT_REV = AnalogPin.P13;\n    export const PIN_MOTOR_RIGHT_FWD = AnalogPin.P14;\n    export const PIN_MOTOR_RIGHT_REV = AnalogPin.P15;\n\n    export const PIN_SONAR_FRONT_TRIG = DigitalPin.P16;\n    export const PIN_SONAR_FRONT_ECHO = DigitalPin.P8;\n    export const PIN_SONAR_BACK_TRIG = DigitalPin.P1;\n    export const PIN_SONAR_BACK_ECHO = DigitalPin.P2;\n\n    export const PIN_UV_SENSOR = AnalogPin.P0;\n\n    // ─── I2C CONFIG ──────────────────────────────────────────────────────────────\n    export const BME680_I2C_ADDRESS = 0x77;\n\n    // ─── SYSTEM CONSTANTS ────────────────────────────────────────────────────────\n    export const MAX_MOTOR_SPEED = 1023;\n    export const DEFAULT_SAFE_DISTANCE_CM = 40;\n    export const SONAR_RETRY_COUNT = 2;\n    export const SONAR_INTERVAL_MS = 80;\n    export const TELEMETRY_INTERVAL_MS = 1000;\n}"},{"type":"added","filename":"datatransfer.ts","value":"namespace Robot.DataTransfer {\n    // ─── CHUNKED DATA TRANSFER WITH CHECKSUM ───────────────────────────────────\n    const MAX_CHUNK_SIZE = 1000; // Max bytes per chunk (well under 16KB limit)\n    // const CHUNK_HEADER_SIZE = 20; // Approximate header overhead (unused but good for reference)\n\n    // Simple checksum: sum of all bytes modulo 65536\n    export function calculateChecksum(data: string): number {\n        let sum = 0;\n        for (let i = 0; i < data.length; i++) {\n            sum = (sum + data.charCodeAt(i)) % 65536;\n        }\n        return sum;\n    }\n\n    // Split large data into chunks with checksums\n    // Format: {\"type\":\"chunk\",\"id\":X,\"seq\":Y,\"total\":Z,\"data\":\"...\",\"csum\":N}\n    export function sendChunkedData(data: string, messageId: number = 0): void {\n        if (data.length <= MAX_CHUNK_SIZE) {\n            // Small enough to send directly with checksum\n            let checksum = calculateChecksum(data);\n            let packet = {\n                type: \"data\",\n                id: messageId,\n                data: data,\n                csum: checksum\n            };\n            bluetooth.uartWriteString(JSON.stringify(packet) + \"\\n\");\n            return;\n        }\n\n        // Split into chunks\n        let totalChunks = Math.idiv(data.length + MAX_CHUNK_SIZE - 1, MAX_CHUNK_SIZE);\n        let chunkId = 0;\n\n        for (let i = 0; i < data.length; i += MAX_CHUNK_SIZE) {\n            let chunkData = data.substr(i, MAX_CHUNK_SIZE);\n            let checksum = calculateChecksum(chunkData);\n\n            let packet = {\n                type: \"chunk\",\n                id: messageId,\n                seq: chunkId,\n                total: totalChunks,\n                data: chunkData,\n                csum: checksum\n            };\n\n            bluetooth.uartWriteString(JSON.stringify(packet) + \"\\n\");\n            chunkId++;\n\n            // Small delay between chunks to avoid overwhelming the buffer\n            basic.pause(10);\n        }\n    }\n\n    // Verify checksum of received data\n    export function verifyChecksum(data: string, expectedChecksum: number): boolean {\n        return calculateChecksum(data) === expectedChecksum;\n    }\n}"},{"type":"added","filename":"dispatcher.ts","value":"namespace Robot.Dispatcher {\n    export function dispatch(cmd: string) {\n        // Fast-path: Check if command looks like JSON before expensive parsing\n        // Numeric commands (\"1\", \"2\", etc.) are handled immediately\n        if (cmd.length > 0 && cmd.charAt(0) === \"{\") {\n            // Only attempt JSON parsing for commands starting with '{'\n            if (!tryParseSettingsMessage(cmd)) {\n                executeCmd(cmd);\n            }\n        } else {\n            // Handle numeric commands directly (most common case)\n            executeCmd(cmd);\n        }\n    }\n\n    // ─── SETTINGS MESSAGE HANDLING ──────────────────────────────────────────────\n    function tryParseSettingsMessage(cmd: string): boolean {\n        try {\n            // Parse as JSON (only called for commands starting with '{')\n            const parsed = JSON.parse(cmd);\n\n            // format: {\"l\":X,\"r\":Y,\"f\":Z,\"b\":W}\n            if (parsed && typeof parsed === \"object\") {\n                let processed = false;\n\n                // Process motor speeds if both are provided\n                if (typeof parsed.l === \"number\" && typeof parsed.r === \"number\") {\n                    const leftSpeed = parsed.l;\n                    const rightSpeed = parsed.r;\n\n                    // Validate and apply motor speeds\n                    if (leftSpeed >= 0 && leftSpeed <= Robot.Config.MAX_MOTOR_SPEED &&\n                        rightSpeed >= 0 && rightSpeed <= Robot.Config.MAX_MOTOR_SPEED) {\n                        Robot.Motion.setMotorSpeeds(leftSpeed, rightSpeed);\n                        processed = true;\n                    }\n                }\n\n                // Process safe distances if both are provided\n                if (typeof parsed.f === \"number\" && typeof parsed.b === \"number\") {\n                    const frontDistance = parsed.f;\n                    const backDistance = parsed.b;\n\n                    // Validate and apply safe distances (20-100cm range)\n                    // We keep these explicit ranges as they might be protocol-specific limits\n                    if (frontDistance >= 20 && frontDistance <= 100 && backDistance >= 5 && backDistance <= 200) {\n                        Robot.Motion.setSafeDistances(frontDistance, backDistance);\n                        processed = true;\n                    }\n                }\n\n                return processed;\n            }\n            return false;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    function executeCmd(cmd: string) {\n        switch (cmd) {\n            case \"1\": Robot.Motion.forward(); break;\n            case \"2\": Robot.Motion.backward(); break;\n            case \"3\": Robot.Motion.spinLeft(); break;\n            case \"4\": Robot.Motion.spinRight(); break;\n            case \"5\": Robot.Motion.turnLeft(); break;\n            case \"6\": Robot.Motion.turnRight(); break;\n            case \"7\": Robot.Motion.turnLeftBackward(); break;\n            case \"8\": Robot.Motion.turnRightBackward(); break;\n            default: Robot.Motion.stop(); break;\n        }\n    }\n}"},{"type":"added","filename":"display.ts","value":"namespace Robot.Display {\n    // ─── UTILITY DISPLAY ─────────────────────────────────────────────────────────\n    let lastDisplayType = \"\";\n    let lastDisplayValue = -1;\n\n    export function showArrowIfChanged(a: ArrowNames) {\n        if (lastDisplayType !== \"arrow\" || lastDisplayValue !== a) {\n            basic.showArrow(a);\n            lastDisplayType = \"arrow\";\n            lastDisplayValue = a;\n        }\n    }\n\n    export function showIconIfChanged(i: IconNames) {\n        if (lastDisplayType !== \"icon\" || lastDisplayValue !== i) {\n            basic.showIcon(i);\n            lastDisplayType = \"icon\";\n            lastDisplayValue = i;\n        }\n    }\n}"},{"type":"added","filename":"motion.ts","value":"// Add your code here\n"},{"type":"added","filename":"sonar.ts","value":"namespace Robot.Sonar {\n    export let frontDistance = 0;\n    export let backDistance = 0;\n\n    function retryPing(trigger: DigitalPin, echo: DigitalPin): number {\n        let d = sonar.ping(trigger, echo, PingUnit.Centimeters);\n        for (let i = 0; d === 0 && i < Robot.Config.SONAR_RETRY_COUNT; i++) {\n            basic.pause(5);\n            basic.pause(0); // yield\n            d = sonar.ping(trigger, echo, PingUnit.Centimeters);\n        }\n        return d || 999;\n    }\n\n    basic.forever(function () {\n        frontDistance = retryPing(Robot.Config.PIN_SONAR_FRONT_TRIG, Robot.Config.PIN_SONAR_FRONT_ECHO);\n        backDistance = retryPing(Robot.Config.PIN_SONAR_BACK_TRIG, Robot.Config.PIN_SONAR_BACK_ECHO);\n\n        if (\n            (Robot.Motion.currentDir > 0 && frontDistance < Robot.Motion.getCurrentFrontSafeDistance()) ||\n            (Robot.Motion.currentDir < 0 && backDistance < Robot.Motion.getCurrentBackSafeDistance())\n        ) {\n            Robot.Motion.stop();\n        }\n        basic.pause(Robot.Config.SONAR_INTERVAL_MS);\n    });\n}\n"},{"type":"added","filename":"state.ts","value":"namespace Robot.State {\n    let _connected = false;\n\n    export function isConnected(): boolean {\n        return _connected;\n    }\n\n    export function setConnected(status: boolean): void {\n        _connected = status;\n    }\n}"},{"type":"added","filename":"telemetry.ts","value":"namespace Robot.Telemetry {\n    // ───────────────── TELEMETRY STATE ─────────────────\n    let lastCpuTemp = -999;\n    let lastBattery = -1;\n    let lastFront = -1;\n    let lastBack = -1;\n    let lastAmbient = -999;\n    let lastHumidity = -1;\n    let lastAirQuality = -1;\n    let lastPressure = -1;\n    let lastUvLevel = -1;\n    let telemetryMessageId = 0;\n\n    let bme680Ready = false;\n\n    // ───── UV SENSOR CALIBRATION ─────\n    let uvBaseline = 0;\n\n    function calibrateUvBaseline() {\n        let sum = 0;\n        let samples = 20;\n        for (let i = 0; i < samples; i++) {\n            sum += pins.analogReadPin(Robot.Config.PIN_UV_SENSOR);\n            basic.pause(20);\n        }\n        uvBaseline = Math.idiv(sum, samples);\n    }\n\n    function readUvLevel(): number {\n        const raw = pins.analogReadPin(Robot.Config.PIN_UV_SENSOR);\n        let corrected = raw - uvBaseline;\n        if (corrected < 0) corrected = 0;\n\n        let span = 1023 - uvBaseline;\n        if (span <= 0) span = 1;\n\n        let uv = Math.idiv(corrected * 11, span);\n        return Math.max(0, Math.min(11, uv));\n    }\n\n    function readBatteryVoltage(): number {\n        // Implement real voltage reading if needed\n        return -1;\n    }\n\n    // ───── PUBLIC STARTUP ─────\n    export function init() {\n        calibrateUvBaseline();\n        bme680Ready = Robot.Drivers.BME680.init();\n    }\n\n    // ───── SEND TELEMETRY ─────\n    export function sendTelemetry() {\n        if (!bme680Ready) {\n            bme680Ready = Robot.Drivers.BME680.init();\n        }\n\n        // Gather Data\n        let cpuTemp = input.temperature();\n        let battery = readBatteryVoltage();\n        let front = Robot.Sonar.frontDistance;\n        let back = Robot.Sonar.backDistance;\n\n        let bme = Robot.Drivers.BME680.readSample();\n        let ambient = bme.ambient;\n        let humidity = bme.humidity;\n        let pressure = bme.pressure;\n        let airQuality = -1; // Disabled\n\n        let uvLevel = readUvLevel();\n\n        // Check for changes\n        const changed =\n            cpuTemp !== lastCpuTemp ||\n            battery !== lastBattery ||\n            front !== lastFront ||\n            back !== lastBack ||\n            ambient !== lastAmbient ||\n            humidity !== lastHumidity ||\n            airQuality !== lastAirQuality ||\n            pressure !== lastPressure ||\n            uvLevel !== lastUvLevel;\n\n        if (!changed) return;\n\n        // Update State\n        lastCpuTemp = cpuTemp;\n        lastBattery = battery;\n        lastFront = front;\n        lastBack = back;\n        lastAmbient = ambient;\n        lastHumidity = humidity;\n        lastAirQuality = airQuality;\n        lastPressure = pressure;\n        lastUvLevel = uvLevel;\n\n        // Build Payload\n        let p: any = { cpu: cpuTemp };\n        if (battery >= 0) p.battery = battery;\n        if (front >= 0) p.front = front;\n        if (back >= 0) p.back = back;\n        if (ambient > -999) p.ambient = ambient;\n        if (humidity >= 0) p.humidity = humidity;\n        if (airQuality >= 0) p.airQuality = airQuality;\n        if (pressure >= 0) p.atmospherePressure = pressure;\n        if (uvLevel >= 0) p.uvLevel = uvLevel;\n\n        // Send\n        Robot.DataTransfer.sendChunkedData(JSON.stringify(p), telemetryMessageId);\n        telemetryMessageId = (telemetryMessageId + 1) & 0xffff;\n    }\n}"}]},{"timestamp":1764551208232,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":237,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":98,"length1":110,"diffs":[[1,"        \"radio\": \"*\",\n        \"microphone\": \"*\"\n"]]},{"start1":456,"length1":330,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":0,"length1":6856,"diffs":[[1,"// Add your code here\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1764550659622,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"clean-microbee\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1764551759033}